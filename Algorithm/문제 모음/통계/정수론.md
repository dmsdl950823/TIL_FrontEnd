# 정수론 (Integer)

> 정수의 성질을 연구하는 분야
> 

## 약수 (Divisor)

> 특정 정수를 나누어 떨어지게 하는 수
> 

```sql
# 20 => 1 2 4 5 10 20

n = int(input())

for i in range(1, n + 1):
	if (n % i == 0): print(i) # 약수인 경우만 출력
```

## 소수 (Prime number)

> 약수가 1과 자기 자신뿐인 정수 (숫자의 ‘원자’)
*⇒ ‘N’ 이 소수인지 여부를 확인하는 문제에서 사용*
> 

### 2 ~ `N - 1` 까지 나누기

```sql
# 1과 N을 제외하고, 내부의 숫자들중에서 (2 ~ N - 1)
# 하나라도 나누어 떨어지는 값이 하나라도 있으면 소수가 아니다. (모두 나누어 떨어지면 안된다)

n = int(input())

flag = True
for i in range(2, n):
    if (n % i == 0):
          flag = False
          break

if (flag == True): print('소수')
else: print('정수')
```

### `n / 2` 까지 나누기

```python
n = int(input())

flag = True
for i in range(2, **n // 2 + 1**):
    if (n % i == 0):
          flag = False
          break

if (flag == True): print('소수')
else: print('정수')
```

### ****`n` 의 제곱근까지 나누기**

```python
n = int(input())

flag = True
for i in range(2, **int(n ** 0.5) + 1**):
    if (n % i == 0):
          flag = False
          break

if (flag == True): print('소수')
else: print('정수')
```

### 에라토스테네스의 체

> 소수를 구하는 방법중 하나
*⇒ “1부터 N까지의 소수를 구해라” 문제 유형에서 사용*
> 
1. 가장 작은 소수를 찾는다. (1 제외)
2. 1에서 찾은 소수의 배수 들은 모두 삭제한다.
3. 계속해서 1, 2를 반복한다.
- 시간 복잡도 : `O(n log n)`

```python
n = int(input())

# 에라토스테네스의 체 초기화: n개 요소에 True 설정(소수로 간주)
sieve = [False, False] + [True] * (n)
primes = []

# n의 최대 약수가 sqrt(n) 이하이므로 i=sqrt(n)까지 검사

for i in range(2, n + 1):
    if (sieve[i] == True):  # i가 소수인 경우
        primes.append(i)
        for j in range(i + i, n, i): # i이후 i의 배수들을 False 판정
            sieve[j] = False

print(primes)
```

## 소인수분해 (Prime factorization)

> 숫자 N을 소수의 곱으로 나타냄 ⇒ ‘소수들의 곱’으로 이루어진 수
> 

```sql
# 60 (/2) => 30 (/2) => 15 (/3) => 5 (/5)
# 작은숫자부터 할 수 있는 만큼 나누는 과정
# 소수 값만 미리 알면 좋겠지만, (2, 3, 5, 7, 11, 13 ...)
# 구현 과정에서 '정수'만으로 나누어도, 소수만 남아있게된다.

n = int(input())
i = 2 # 3, 4, 5, 6, 7, 8, 9, 10 ... 정수 1씩 계속 증가

while (n > 1):
	if (n % i == 0):
		print(i, end=' ')
		n //= i
	else:
		i += 1

	# print(n)
	# 60  => 2 2 3 5
	# 180 => 2 2 3 3 5
```

## 공약수와 공배수

- A와 B의 공약수
    
    ⇒ A의 약수이면서 동시에 B의 약수인 수
    
- A와 B의 공배수
    
    ⇒ A의 배수이면서 동시에 B의 배수인 수
    

## 최대공약수와 최대공배수

- A와 B의 **최대공약수** (GCD: Greatest Common Divisor)
    
    ⇒ A의 약수이면서 동시에 B의 약수인 수 중 최댓값
    
- A와 B의 **최소공배수** (LCM: Lower Common Multiplier)
    
    ⇒ A의 배수이면서 동시에 B의 배수인 수 중 최솟값
    

### 유클리드 호제법

- 최대공약수를 구하기 위한 알고리즘
    1. 두개의 수 `a`, `b` ⇒ `r` (`a % b` 나머지 대입)
    2. `a` = `b`, `b` = `r`, 위치 이동 ⇒  `r` (`a % b` 나머지 대입)
    3. `r`에서 구해진 (`a % b`) 나머지가 `0`이 될때까지 2번을 계속 반복함
    4. `0`이 된 경우, `b`가 최대공약수

```sql
# a    b   r
# 158  86  72
#  86  72  14
#  72  14  2
#  14  2   0  => 최대공약수 2

a, b = list(map(int, input().split()))

A, B = a, b # 원본 저장

GCD = 0 # 최대공약수 (G)
LCM = 0 # 최소공배수 (abG)

while (True):
	r = a % b
	
	if (r == 0):
		GCD = b
		break
	
	a = b
	b = r # a, b = b, r

# A  B        G(최대공약수)
# A = aG, a = A/G
# B = bG, b = B/G
# L = abG (최소공배수)
LCM = int((A / GCD) * (B / GCD) * GCD)

print('최대공약수 : ', GCD)
print('최소공배수 : ', LCM)
```

---

## 파스칼의 삼각형

- [조합] 과 연관이 있음
- `nCr` ⇒ `c`개 중에서 `r`개를 선택하는 방법 경우의 수