# Shaders

Shader 는 Three.js 내장 API를 사용하여 생성할때, 해당 API 들은 shader 로 작성되어있는 방식들입니다. WebGL 렌더에서 보여지는 모든것들은 shader 덕분에 가능한 것이지만, 직접 만들어야할 때가 많습니다.

이제부터 언제, 무슨 shader 를 사용해야하는지부터 배울 것 입니다. 그리고는 shader 문법을 배워 간단한 shader 들을 만들것입니다. 


# Shader 란?

shader 는, 사실 WebGL 의 주요 컴포넌트중 하나입니다. 만약 WebGL 을 Three.js 없이 사용하게 된다면, 제일 먼저 배워야 하는게 shader 입니다. 그러나 이 개념은 매우 어렵죠.

shader 는 GLSL 로 작성됩니다. GLSL 은 GPU 로 보내지며, 각 geometry 의 꼭지점의 위치가 사용되고, 그 geomtry 의 보이는 pixel 색상을 보여줍니다. 여기서 "pixel" 은 정확하지 않습니다 - 왜냐하면 렌더링의 각 포인트는 필수적으로 스크린의 각 pixel 에 일치하는 것은 아니기 때문입니다. 그리고 이것이 왜 우리가 "**fragment** (파편)" 라는 용어를 선호하는지 에 대한 이유입니다. 

아무튼, 그 후, 우리는 많은 데이터를 shader 에게 보냅니다. 예를들어 꼭짓점 위치, mesh transformation, camera 정보, 우리가 보는 view, 생상, 질감, 조명, 안개 등등의 parameter 등을 말이죠. 그러면 GPU 는 이 모든 데이터를 shader 의 가이드에 따라 처리하며, 우리의 geometry 는 렌더되어 화면에 표시됩니다.

두 가지 타입의 shader 가 있으며, 둘 다 필요합니다.

## Vertex shader

The vertex shader's purpose is to position the vertices of the geometry. The idea is to send the vertices positions, the mesh transformations (like its position, rotation, and scale), the camera information (like its position, rotation, and field of view). Then, the GPU will follow the instructions in the vertex shader to process all of this information in order to project the vertices on a 2D space that will become our render —in other words, our canvas.

When using a vertex shader, its code will be applied on every vertex of the geometry. But some data like the vertex position will change between each vertex. This type of data —the one that changes between vertices— is called an attribute. But some data doesn't need to switch between each vertex like the position of the mesh. Yes, the location of the mesh will impact all the vertices, but in the same way. This type of data —the one that doesn't change between vertices— is called a uniform. We will get back to attributes and uniforms later.

The vertex shader happens first. Once the vertices are placed, the GPU knows what pixels of the geometry are visible and can proceed to the fragment shader.

## Fragment shader

The fragment shader purpose is to color each visible fragment of the geometry.

The same fragment shader will be used for every visible fragment of the geometry. We can send data to it like a color by using uniforms —just like the vertex shader, or we can send data from the vertex shader to the fragment shader. We call this type of data —the one that comes from the vertex shader to the fragment shader— varying. We will get back to this later.

The most straightforward instruction in a fragment shader can be to color all the fragments with the same color. We get the equivalent of the MeshBasicMaterial —if we had set only the color property.

Or we can send more data to the shader, for instance, a light position. We can then color the fragments according to how much the face is in front of the light source. We would get the MeshPhongMaterial equivalent—if we had one light in the scene.

