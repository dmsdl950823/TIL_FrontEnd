- [Shaders](#shaders)
- [Shader 란?](#shader-란)
  - [Vertex shader](#vertex-shader)
  - [Fragment shader](#fragment-shader)
  - [결론](#결론)
- [자신만의 shader 를 사용해야 하는 이유](#자신만의-shader-를-사용해야-하는-이유)

# Shaders

Shader 는 Three.js 내장 API를 사용하여 생성할때, 해당 API 들은 shader 로 작성되어있는 방식들입니다. WebGL 렌더에서 보여지는 모든것들은 shader 덕분에 가능한 것이지만, 직접 만들어야할 때가 많습니다.

이제부터 언제, 무슨 shader 를 사용해야하는지부터 배울 것 입니다. 그리고는 shader 문법을 배워 간단한 shader 들을 만들것입니다. 


# Shader 란?

shader 는, 사실 WebGL 의 주요 컴포넌트중 하나입니다. 만약 WebGL 을 Three.js 없이 사용하게 된다면, 제일 먼저 배워야 하는게 shader 입니다. 그러나 이 개념은 매우 어렵죠.

shader 는 GLSL 로 작성됩니다. GLSL 은 GPU 로 보내지며, 각 geometry 의 꼭지점의 위치가 사용되고, 그 geomtry 의 보이는 pixel 색상을 보여줍니다. 여기서 "pixel" 은 정확하지 않습니다 - 왜냐하면 렌더링의 각 포인트는 필수적으로 스크린의 각 pixel 에 일치하는 것은 아니기 때문입니다. 그리고 이것이 왜 우리가 "**fragment** (파편)" 라는 용어를 선호하는지 에 대한 이유입니다. 

아무튼, 그 후, 우리는 많은 데이터를 shader 에게 보냅니다. 예를들어 꼭짓점 위치, mesh transformation, camera 정보, 우리가 보는 view, 생상, 질감, 조명, 안개 등등의 parameter 등을 말이죠. 그러면 GPU 는 이 모든 데이터를 shader 의 가이드에 따라 처리하며, 우리의 geometry 는 렌더되어 화면에 표시됩니다.

두 가지 타입의 shader 가 있으며, 둘 다 필요합니다.

## Vertex shader

*vertex shader* 의 목적은 geometry 의 꼭짓점 위치(position)를 나타내기 위함입니다. 해당 개념은 꼭지점 위치(position), mesh 의 변형 (position, rotation, scale 등), 카메라 정보 (position, rotation, field of view 등) 을 전송합니다. 그리고 GPU 는 vertex shader 안에 있는 정보를 따라 프로젝트를 2D 공간에 렌더링 하기위해서 - canvas에 모든 정보를 처리합니다.

vertex shader 를 사용할 때, 이 코드는 모든 geometry 의 꼭지점에 적용될 것입니다. 
* 몇몇 데이터 (꼭지점 position 등 과 같이..)는 각 꼭지점을 변경시킬것 입니다. 꼭지점 사이를 변경하는 이러한 데이터는, `attribute` 라고 부릅니다.
* 그러나 몇몇 데이터는 각 꼭짓점 위치 사이를 변경할 필요는 없습니다. 꼭지점 사이를 변경하지 않는, 이러한 데이터는 `uniform` 이라고 부릅니다.

이 두 데이터 타입은 뒤에서 배울 것 입니다.

vertex shader 는 제일먼저 발생합니다. 일단 꼭짓점이 생성되어 위치되면, GPU 는 geometry 의 어떠한 픽셀들이 보이게 되며, 그 후 fragment shader 로 전달됩니다.

## Fragment shader

*fragment shader* 의 목적은 geometry 에 보이는 각 파편(fragment) 들 에게 색상을 입히는 것 입니다.

같은 fragment shader 는 모든 geometry 의 보이는 모든 파편에 사용됩니다. 우리는 데이터를 fragment shader 에 전달하여, `uniforms` 를 사용하여 컬러를 설정할 수 있습니다. vetex shader 와 같이, 또는 vertex shader 에서 전달받은 데이터(이러한 타입의 데이터를 `varying` 이라고 부릅니다. 이 데이터는 후에 확인할 것 입니다)를 활용할 수 있습니다.

fragment shader 에서 가장 직접적인 정보는 모든 파편들에게 모두 같은 color 를 입히도록 하는 것 입니다. 색상 특성만 잘 설정했다면 [MeshBasicMaterial](https://threejs.org/docs/index.html#api/en/materials/MeshBasicMaterial)과 같은 결과를 얻을 수 있습니다.

또는 데이터를 shader 에게 전달해 줄 수도 있습니다.(ex. light 위치) 그리고 얼마나 많은 물체들/표면들이 해당 light 자원을 받고있는지에 따라서 해당 파편에 색상을 입힐 수 있습니다. 이 결과는 한 개의 light 를 scene 에 가지고 있다면, [MeshPhongMaterial](https://threejs.org/docs/index.html#api/en/materials/MeshPhongMaterial) 와 같은 결과를 얻을 수 있습니다.


## 결론

**vertex shader** 는 꼭지점의 position 을 렌더링한다.

**fragment shader** 는 geometry 의 보여지는 각 파편/표면(fragment) 의 색상을 표현한다.

**fragment shader** 는 **vertex shader** 다음에 실행된다.

(position 등과 같이) 각 꼭지점의 변화는 `attribute` 라고 불리며, **vertex shader** 에서만 사용된다.

(position 이나 color 등과 같이) 각 꼭지점이 변하지 않는 데이터는 `uniform` 이라고 불리며, **vertex shader** 와 **fragment shader** 둘다 사용 가능하다.

`varying` 을 통해 **vertext shader** 에서 **fragment shader** 로 데이터를 내보낼 수 있다.


# 자신만의 shader 를 사용해야 하는 이유
